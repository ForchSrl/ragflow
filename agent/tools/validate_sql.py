#
#  Copyright 2024 The InfiniFlow Authors. All Rights Reserved.
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
#
import os
import re
import logging
from abc import ABC

from agent.tools.base import ToolParamBase, ToolBase, ToolMeta
from api.utils.api_utils import timeout

logger = logging.getLogger(__name__)


class ValidateSQLParam(ToolParamBase):
    """Parameter definition for ValidateSQL tool."""

    def __init__(self):
        self.meta: ToolMeta = {
            "name": "validate_sql",
            "description": "Validates and normalizes a single read-only SQL statement; injects safe limits.",
            "parameters": {
                "sql": {
                    "type": "string",
                    "description": "The SQL generated by the agent.",
                    "default": "{sys.query}",
                    "required": True,
                },
                "db_type": {
                    "type": "string",
                    "description": "Database dialect (mysql|postgresql|mariadb|mssql).",
                    "default": "mssql",
                    "required": True,
                },
                "max_limit": {
                    "type": "number",
                    "description": "Maximum number of rows to return (safety).",
                    "default": 1000,
                    "required": False,
                },
            },
        }
        super().__init__()
        self.sql = ""
        self.db_type = "mssql"
        self.max_limit = 1000

    def check(self):
        if not self.sql or not isinstance(self.sql, str):
            raise ValueError("SQL must be a non-empty string")
        if self.db_type not in ["mysql", "postgresql", "mariadb", "mssql"]:
            raise ValueError("Unsupported db_type")
        if int(self.max_limit) <= 0:
            raise ValueError("max_limit must be positive")


class ValidateSQL(ToolBase, ABC):
    component_name = "ValidateSQL"

    @timeout(os.environ.get("COMPONENT_EXEC_TIMEOUT", 30))
    def _invoke(self, **kwargs):
        sql = (kwargs.get("sql") or "").strip()
        db_type = (kwargs.get("db_type") or self._param.db_type).lower()
        max_limit = int(kwargs.get("max_limit") or self._param.max_limit or 1000)

        logger.info(f"ValidateSQL: Incoming SQL: {sql}")

        # Extract SQL from possible prose + fenced markdown code blocks
        src = sql or ""
        mblock = re.search(r"```\s*sql\s*\n(.*?)```", src, re.IGNORECASE | re.DOTALL)
        if not mblock:
            mblock = re.search(r"```\s*\n(.*?)```", src, re.IGNORECASE | re.DOTALL)
        if mblock:
            s = mblock.group(1).strip()
        else:
            # Fallback: cut leading prose until the first DB directive or SELECT/WITH
            mdir = re.search(r"(?i)(?:^|\n)\s*(--\s*DB\s*:|/\*\s*DB\s*:)", src)
            msel = re.search(r"(?i)\bWITH\b|\bSELECT\b", src)
            cut = None
            if mdir:
                cut = mdir.start()
            if msel and (cut is None or msel.start() < cut):
                cut = msel.start()
            s = src[cut:].strip() if cut is not None else src.strip()
        # Capture and temporarily strip leading DB override directive for validation,
        # then re-attach it to the sanitized SQL so downstream executors can honor it.
        # Supported forms (must appear at the very beginning, ignoring leading whitespace):
        #   -- DB: MyDatabase
        #   /* DB: MyDatabase */
        db_override = None
        # Support forms like:
        #   -- DB: FORCH_NAVISION
        #   -- DB: FORCH_NAVISION (default)
        #   -- DB: [FORCH_NAVISION]
        # and block comment variants: /* DB: FORCH_NAVISION */ (with optional (..))
        m = re.match(
            r"^\s*--\s*DB\s*:\s*(?:\[(?P<dbbr>[^\]]+)\]|(?P<db>[A-Za-z0-9_.$-]+))(?:\s*\([^)]*\))?\s*(?:\r?\n|$)",
            s,
            re.IGNORECASE,
        )
        if m:
            db_override = m.group("dbbr") or m.group("db")
            s = s[m.end():].lstrip()
        else:
            m2 = re.match(
                r"^\s*/\*\s*DB\s*:\s*(?:\[(?P<dbbr>[^\]]+)\]|(?P<db>[A-Za-z0-9_.$-]+))(?:\s*\([^)]*\))?\s*\*/\s*",
                s,
                re.IGNORECASE,
            )
            if m2:
                db_override = m2.group("dbbr") or m2.group("db")
                s = s[m2.end():].lstrip()
        s = re.sub(r"\[ID:[0-9]+\]", "", s)
        if s.endswith(';'):
            s = s[:-1]
        try:
            if ';' in s:
                raise Exception("Only a single SQL statement is allowed.")
            if re.search(r"\b(INSERT|UPDATE|DELETE|MERGE|ALTER|CREATE|DROP|TRUNCATE|GRANT|EXEC|CALL|BULK INSERT|OPENROWSET|WRITETEXT|UPDATETEXT|DBCC|SHUTDOWN|BACKUP|RESTORE|RECONFIGURE|KILL|DENY|REVOKE|SET)\b", s, re.IGNORECASE):
                raise Exception("Only read-only SELECT queries are allowed.")
            if not re.match(r"^(\s*WITH\b|\s*SELECT\b)", s, re.IGNORECASE):
                raise Exception("Query must be a SELECT (optionally with CTE).")
        except Exception as e:
            logger.error(f"ValidateSQL: SQL validation failed for '{sql}': {e}")
            raise

        if db_type in ("mysql", "mariadb", "postgresql"):
            if not re.search(r"\bLIMIT\b|\bOFFSET\s+\d+\s+ROWS\b", s, re.IGNORECASE):
                s = f"{s} LIMIT {max_limit}"
        elif db_type == "mssql":
            # Normalize MySQL-style backticks to MSSQL brackets, and split schema.table if present
            def _bt_repl(m):
                ident = m.group(1)
                if "." in ident:
                    left, right = ident.split(".", 1)
                    return f"[{left}].[{right}]"
                return f"[{ident}]"
            s = re.sub(r"`([^`]+)`", _bt_repl, s)
            # Convert double-quoted identifiers to brackets as well
            def _dq_repl(m):
                ident = m.group(1)
                if "." in ident:
                    left, right = ident.split(".", 1)
                    return f"[{left}].[{right}]"
                return f"[{ident}]"
            s = re.sub(r'"([^"]+)"', _dq_repl, s)
            # Normalize: remove MySQL/Postgres-style LIMIT/OFFSET if present
            # Capture LIMIT n and use it as the cap for TOP if provided
            lim_match = re.search(r"\bLIMIT\s+(\d+)\b", s, re.IGNORECASE)
            if lim_match:
                try:
                    max_limit = min(max_limit, int(lim_match.group(1)))
                except Exception:
                    pass
                # Remove trailing LIMIT clause
                s = re.sub(r"\s+LIMIT\s+\d+\b\s*;?\s*$", "", s, flags=re.IGNORECASE)
            # Remove bare OFFSET if present (without FETCH NEXT)
            s = re.sub(r"\s+OFFSET\s+\d+\s*;?\s*$", "", s, flags=re.IGNORECASE)
            if not re.search(r"\bTOP\b|\bFETCH\s+NEXT\b", s, re.IGNORECASE):
                if re.match(r"\s*SELECT\s+DISTINCT\b", s, re.IGNORECASE):
                    s = re.sub(r"^\s*SELECT\s+DISTINCT\s+", f"SELECT DISTINCT TOP {max_limit} ", s, flags=re.IGNORECASE)
                else:
                    s = re.sub(r"^\s*SELECT\s+", f"SELECT TOP {max_limit} ", s, flags=re.IGNORECASE)

        # Re-attach DB override directive if it was present initially so ExeSQL can parse it.
        if db_override:
            s = f"-- DB: {db_override}\n" + s

        self.set_output("sql", s)
        return s

    def thoughts(self) -> str:
        return "Sanitizing SQL before execution."
